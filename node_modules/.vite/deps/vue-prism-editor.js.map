{
  "version": 3,
  "sources": ["../../vue-prism-editor/src/Editor.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { defineComponent, h } from 'vue';\n\nimport './styles.css';\nconst KEYCODE_ENTER = 13;\nconst KEYCODE_TAB = 9;\nconst KEYCODE_BACKSPACE = 8;\nconst KEYCODE_Y = 89;\nconst KEYCODE_Z = 90;\nconst KEYCODE_M = 77;\nconst KEYCODE_PARENS = 57;\nconst KEYCODE_BRACKETS = 219;\nconst KEYCODE_QUOTE = 222;\nconst KEYCODE_BACK_QUOTE = 192;\nconst KEYCODE_ESCAPE = 27;\n\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\n\nconst isWindows = typeof window !== 'undefined' && navigator && /Win/i.test(navigator.platform);\nconst isMacLike = typeof window !== 'undefined' && navigator && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n\nexport interface EditorProps {\n  lineNumbers: boolean;\n  autoStyleLineNumbers: boolean;\n  readonly: boolean;\n  value: string;\n  highlight: () => string;\n  tabSize: number;\n  insertSpaces: boolean;\n  ignoreTabKey: boolean;\n  placeholder: string;\n}\nexport interface Record {\n  value: string;\n  selectionStart: number;\n  selectionEnd: number;\n}\n\nexport interface History {\n  stack: Array<Record & { timestamp: number }>;\n  offset: number;\n}\n\nexport const PrismEditor = defineComponent({\n  props: {\n    lineNumbers: {\n      type: Boolean,\n      default: false,\n    },\n    autoStyleLineNumbers: {\n      type: Boolean,\n      default: true,\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n    modelValue: {\n      type: String,\n      default: '',\n    },\n    highlight: {\n      type: Function,\n      required: true,\n    },\n    tabSize: {\n      type: Number,\n      default: 2,\n    },\n    insertSpaces: {\n      type: Boolean,\n      default: true,\n    },\n    ignoreTabKey: {\n      type: Boolean,\n      default: false,\n    },\n    placeholder: {\n      type: String,\n      default: '',\n    },\n  },\n  data() {\n    return {\n      capture: true,\n      history: {\n        stack: [],\n        offset: -1,\n      } as History,\n      lineNumbersHeight: '20px',\n      codeData: '',\n    };\n  },\n  watch: {\n    modelValue: {\n      immediate: true,\n      handler(newVal: string): void {\n        if (!newVal) {\n          this.codeData = '';\n        } else {\n          this.codeData = newVal;\n        }\n      },\n    },\n    content: {\n      immediate: true,\n      handler(): void {\n        if (this.lineNumbers) {\n          this.$nextTick(() => {\n            this.setLineNumbersHeight();\n          });\n        }\n      },\n    },\n    lineNumbers(): void {\n      this.$nextTick(() => {\n        this.styleLineNumbers();\n        this.setLineNumbersHeight();\n      });\n    },\n  },\n  computed: {\n    isEmpty(): boolean {\n      return this.codeData.length === 0;\n    },\n    content(): string {\n      const result = this.highlight(this.codeData) + '<br />';\n      // todo: VNode support?\n      return result;\n    },\n    lineNumbersCount(): number {\n      const totalLines = this.codeData.split(/\\r\\n|\\n/).length;\n      return totalLines;\n    },\n  },\n  mounted() {\n    this._recordCurrentState();\n    this.styleLineNumbers();\n  },\n\n  methods: {\n    setLineNumbersHeight(): void {\n      this.lineNumbersHeight = getComputedStyle(this.$refs.pre as HTMLTextAreaElement).height;\n    },\n    styleLineNumbers(): void {\n      if (!this.lineNumbers || !this.autoStyleLineNumbers) return;\n\n      const $editor = this.$refs.pre as HTMLTextAreaElement;\n      const $lineNumbers: HTMLDivElement | null = this.$el.querySelector('.prism-editor__line-numbers');\n      const editorStyles = window.getComputedStyle($editor);\n\n      this.$nextTick(() => {\n        const btlr: any = 'border-top-left-radius';\n        const bblr: any = 'border-bottom-left-radius';\n        if (!$lineNumbers) return;\n        $lineNumbers.style[btlr] = editorStyles[btlr];\n        $lineNumbers.style[bblr] = editorStyles[bblr];\n        $editor.style[btlr] = '0';\n        $editor.style[bblr] = '0';\n\n        const stylesList = ['background-color', 'margin-top', 'padding-top', 'font-family', 'font-size', 'line-height'];\n        stylesList.forEach((style: any) => {\n          $lineNumbers.style[style] = editorStyles[style];\n        });\n        $lineNumbers.style['margin-bottom' as any] = '-' + editorStyles['padding-top' as any];\n      });\n    },\n    _recordCurrentState(): void {\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n\n      if (!input) return;\n      // Save current state of the input\n      const { value, selectionStart, selectionEnd } = input;\n\n      this._recordChange({\n        value,\n        selectionStart,\n        selectionEnd,\n      });\n    },\n    _getLines(text: string, position: number): Array<string> {\n      return text.substring(0, position).split('\\n');\n    },\n    _applyEdits(record: Record): void {\n      // Save last selection state\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n      const last = this.history.stack[this.history.offset];\n\n      if (last && input) {\n        this.history.stack[this.history.offset] = {\n          ...last,\n          selectionStart: input.selectionStart,\n          selectionEnd: input.selectionEnd,\n        };\n      }\n\n      // Save the changes\n      this._recordChange(record);\n      this._updateInput(record);\n    },\n    _recordChange(record: Record, overwrite = false): void {\n      const { stack, offset } = this.history;\n\n      if (stack.length && offset > -1) {\n        // When something updates, drop the redo operations\n        this.history.stack = stack.slice(0, offset + 1);\n\n        // Limit the number of operations to 100\n        const count = this.history.stack.length;\n\n        if (count > HISTORY_LIMIT) {\n          const extras = count - HISTORY_LIMIT;\n\n          this.history.stack = stack.slice(extras, count);\n          this.history.offset = Math.max(this.history.offset - extras, 0);\n        }\n      }\n\n      const timestamp = Date.now();\n\n      if (overwrite) {\n        const last = this.history.stack[this.history.offset];\n\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n          // A previous entry exists and was in short interval\n\n          // Match the last word in the line\n          const re = /[^a-z0-9]([a-z0-9]+)$/i;\n\n          // Get the previous line\n          const previous = this._getLines(last.value, last.selectionStart).pop()?.match(re);\n\n          // Get the current line\n          const current = this._getLines(record.value, record.selectionStart).pop()?.match(re);\n\n          if (previous && current && current[1].startsWith(previous[1])) {\n            // The last word of the previous line and current line match\n            // Overwrite previous entry so that undo will remove whole word\n            this.history.stack[this.history.offset] = {\n              ...record,\n              timestamp,\n            };\n\n            return;\n          }\n        }\n      }\n\n      // Add the new operation to the stack\n      this.history.stack.push({ ...record, timestamp });\n      this.history.offset++;\n    },\n\n    _updateInput(record: Record): void {\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n\n      if (!input) return;\n\n      // Update values and selection state\n      input.value = record.value;\n      input.selectionStart = record.selectionStart;\n      input.selectionEnd = record.selectionEnd;\n\n      this.$emit('update:modelValue', record.value);\n      // this.props.onValueChange(record.value);\n    },\n    handleChange(e: KeyboardEvent): void {\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\n\n      this._recordChange(\n        {\n          value,\n          selectionStart,\n          selectionEnd,\n        },\n        true\n      );\n      this.$emit('update:modelValue', value);\n      // this.props.onValueChange(value);\n    },\n    _undoEdit(): void {\n      const { stack, offset } = this.history;\n\n      // Get the previous edit\n      const record = stack[offset - 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n        this.history.offset = Math.max(offset - 1, 0);\n      }\n    },\n    _redoEdit(): void {\n      const { stack, offset } = this.history;\n\n      // Get the next edit\n      const record = stack[offset + 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n        this.history.offset = Math.min(offset + 1, stack.length - 1);\n      }\n    },\n    handleKeyDown(e: KeyboardEvent): void {\n      // console.log(navigator.platform);\n      const { tabSize, insertSpaces, ignoreTabKey } = this;\n\n      // onKeyDown(e);\n      this.$emit('keydown', e);\n\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      if (e.keyCode === KEYCODE_ESCAPE) {\n        (<HTMLTextAreaElement>e.target).blur();\n        this.$emit('blur', e);\n      }\n\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\n\n      const tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.capture) {\n        // Prevent focus change\n        e.preventDefault();\n\n        if (e.shiftKey) {\n          // Unindent selected lines\n          const linesBeforeCaret = this._getLines(value, selectionStart);\n          const startLine = linesBeforeCaret.length - 1;\n          const endLine = this._getLines(value, selectionEnd).length - 1;\n          const nextValue = value\n            .split('\\n')\n            .map((line, i) => {\n              if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\n                return line.substring(tabCharacter.length);\n              }\n\n              return line;\n            })\n            .join('\\n');\n\n          if (value !== nextValue) {\n            const startLineText = linesBeforeCaret[startLine];\n\n            this._applyEdits({\n              value: nextValue,\n              // Move the start cursor if first line in selection was modified\n              // It was modified only if it started with a tab\n              selectionStart: startLineText.startsWith(tabCharacter)\n                ? selectionStart - tabCharacter.length\n                : selectionStart,\n              // Move the end cursor by total number of characters removed\n              selectionEnd: selectionEnd - (value.length - nextValue.length),\n            });\n          }\n        } else if (selectionStart !== selectionEnd) {\n          // Indent selected lines\n          const linesBeforeCaret = this._getLines(value, selectionStart);\n          const startLine = linesBeforeCaret.length - 1;\n          const endLine = this._getLines(value, selectionEnd).length - 1;\n          const startLineText = linesBeforeCaret[startLine];\n\n          this._applyEdits({\n            value: value\n              .split('\\n')\n              .map((line, i) => {\n                if (i >= startLine && i <= endLine) {\n                  return tabCharacter + line;\n                }\n\n                return line;\n              })\n              .join('\\n'),\n            // Move the start cursor by number of characters added in first line of selection\n            // Don't move it if it there was no text before cursor\n            selectionStart: /\\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters added\n            selectionEnd: selectionEnd + tabCharacter.length * (endLine - startLine + 1),\n          });\n        } else {\n          const updatedSelection = selectionStart + tabCharacter.length;\n\n          this._applyEdits({\n            // Insert tab character at caret\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\n        const hasSelection = selectionStart !== selectionEnd;\n        const textBeforeCaret = value.substring(0, selectionStart);\n\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n          // Prevent default delete behaviour\n          e.preventDefault();\n\n          const updatedSelection = selectionStart - tabCharacter.length;\n\n          this._applyEdits({\n            // Remove tab character at caret\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      } else if (e.keyCode === KEYCODE_ENTER) {\n        // Ignore selections\n        if (selectionStart === selectionEnd) {\n          // Get the current line\n          const line = this._getLines(value, selectionStart).pop();\n          const matches = line?.match(/^\\s+/);\n\n          if (matches && matches[0]) {\n            e.preventDefault();\n\n            // Preserve indentation on inserting a new line\n            const indent = '\\n' + matches[0];\n            const updatedSelection = selectionStart + indent.length;\n\n            this._applyEdits({\n              // Insert indentation character at caret\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n              // Update caret position\n              selectionStart: updatedSelection,\n              selectionEnd: updatedSelection,\n            });\n          }\n        }\n      } else if (\n        e.keyCode === KEYCODE_PARENS ||\n        e.keyCode === KEYCODE_BRACKETS ||\n        e.keyCode === KEYCODE_QUOTE ||\n        e.keyCode === KEYCODE_BACK_QUOTE\n      ) {\n        let chars;\n\n        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n          chars = ['(', ')'];\n        } else if (e.keyCode === KEYCODE_BRACKETS) {\n          if (e.shiftKey) {\n            chars = ['{', '}'];\n          } else {\n            chars = ['[', ']'];\n          }\n        } else if (e.keyCode === KEYCODE_QUOTE) {\n          if (e.shiftKey) {\n            chars = ['\"', '\"'];\n          } else {\n            chars = [\"'\", \"'\"];\n          }\n        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n          chars = ['`', '`'];\n        }\n\n        // console.log(isMacLike, \"navigator\" in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform));\n\n        // If text is selected, wrap them in the characters\n        if (selectionStart !== selectionEnd && chars) {\n          e.preventDefault();\n\n          this._applyEdits({\n            value:\n              value.substring(0, selectionStart) +\n              chars[0] +\n              value.substring(selectionStart, selectionEnd) +\n              chars[1] +\n              value.substring(selectionEnd),\n            // Update caret position\n            selectionStart,\n            selectionEnd: selectionEnd + 2,\n          });\n        }\n      } else if (\n        (isMacLike\n          ? // Trigger undo with \u2318+Z on Mac\n            e.metaKey && e.keyCode === KEYCODE_Z\n          : // Trigger undo with Ctrl+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z) &&\n        !e.shiftKey &&\n        !e.altKey\n      ) {\n        e.preventDefault();\n\n        this._undoEdit();\n      } else if (\n        (isMacLike\n          ? // Trigger redo with \u2318+Shift+Z on Mac\n            e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\n          : isWindows\n          ? // Trigger redo with Ctrl+Y on Windows\n            e.ctrlKey && e.keyCode === KEYCODE_Y\n          : // Trigger redo with Ctrl+Shift+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\n        !e.altKey\n      ) {\n        e.preventDefault();\n\n        this._redoEdit();\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n        e.preventDefault();\n\n        // Toggle capturing tab key so users can focus away\n        this.capture = !this.capture;\n      }\n    },\n  },\n  render() {\n    const lineNumberWidthCalculator = h(\n      'div',\n      {\n        class: 'prism-editor__line-width-calc',\n        style: 'height: 0px; visibility: hidden; pointer-events: none;',\n      },\n      '999'\n    );\n    const lineNumbers = h(\n      'div',\n      {\n        class: 'prism-editor__line-numbers',\n        style: {\n          'min-height': this.lineNumbersHeight,\n        },\n        'aria-hidden': 'true',\n      },\n      [\n        lineNumberWidthCalculator,\n        Array.from(Array(this.lineNumbersCount).keys()).map((_, index) => {\n          return h('div', { class: 'prism-editor__line-number token comment' }, `${++index}`);\n        }),\n      ]\n    );\n\n    const textarea = h('textarea', {\n      ref: 'textarea',\n      onInput: this.handleChange,\n      onKeydown: this.handleKeyDown,\n      onClick: ($event: MouseEvent) => {\n        this.$emit('click', $event);\n      },\n      onKeyup: ($event: KeyboardEvent) => {\n        this.$emit('keyup', $event);\n      },\n      onFocus: ($event: FocusEvent) => {\n        this.$emit('focus', $event);\n      },\n      onBlur: ($event: FocusEvent) => {\n        this.$emit('blur', $event);\n      },\n      class: {\n        'prism-editor__textarea': true,\n        'prism-editor__textarea--empty': this.isEmpty,\n      },\n      spellCheck: 'false',\n      autocapitalize: 'off',\n      autocomplete: 'off',\n      autocorrect: 'off',\n      'data-gramm': 'false',\n      placeholder: this.placeholder,\n      'data-testid': 'textarea',\n      readonly: this.readonly,\n      value: this.codeData,\n    });\n    const preview = h('pre', {\n      ref: 'pre',\n      class: 'prism-editor__editor',\n      'data-testid': 'preview',\n      innerHTML: this.content,\n    });\n    const editorContainer = h('div', { class: 'prism-editor__container' }, [textarea, preview]);\n    return h('div', { class: 'prism-editor-wrapper' }, [this.lineNumbers && lineNumbers, editorContainer]);\n  },\n});\n"],
  "mappings": "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",
  "names": ["KEYCODE_ENTER", "KEYCODE_TAB", "KEYCODE_BACKSPACE", "KEYCODE_Y", "KEYCODE_Z", "KEYCODE_M", "KEYCODE_PARENS", "KEYCODE_BRACKETS", "KEYCODE_QUOTE", "KEYCODE_BACK_QUOTE", "KEYCODE_ESCAPE", "HISTORY_LIMIT", "HISTORY_TIME_GAP", "isWindows", "window", "navigator", "test", "platform", "isMacLike", "PrismEditor", "defineComponent", "props", "lineNumbers", "type", "Boolean", "autoStyleLineNumbers", "readonly", "modelValue", "String", "highlight", "Function", "required", "tabSize", "Number", "insertSpaces", "ignoreTabKey", "placeholder", "data", "capture", "history", "stack", "offset", "lineNumbersHeight", "codeData", "watch", "immediate", "handler", "newVal", "content", "$nextTick", "setLineNumbersHeight", "styleLineNumbers", "computed", "isEmpty", "length", "result", "lineNumbersCount", "totalLines", "split", "mounted", "_recordCurrentState", "methods", "getComputedStyle", "$refs", "pre", "height", "$editor", "$lineNumbers", "$el", "querySelector", "editorStyles", "btlr", "bblr", "style", "stylesList", "forEach", "input", "textarea", "value", "selectionStart", "selectionEnd", "_recordChange", "_getLines", "text", "position", "substring", "_applyEdits", "record", "last", "_updateInput", "overwrite", "slice", "count", "extras", "Math", "max", "timestamp", "Date", "now", "re", "previous", "pop", "match", "current", "startsWith", "push", "$emit", "handleChange", "e", "target", "_undoEdit", "_redoEdit", "min", "handleKeyDown", "defaultPrevented", "keyCode", "blur", "tabCharacter", "repeat", "preventDefault", "shiftKey", "linesBeforeCaret", "startLine", "endLine", "nextValue", "map", "line", "i", "join", "startLineText", "updatedSelection", "hasSelection", "textBeforeCaret", "endsWith", "matches", "indent", "chars", "metaKey", "ctrlKey", "altKey", "render", "lineNumberWidthCalculator", "h", "Array", "from", "keys", "_", "index", "ref", "onInput", "onKeydown", "onClick", "$event", "onKeyup", "onFocus", "onBlur", "spellCheck", "autocapitalize", "autocomplete", "autocorrect", "preview", "innerHTML", "editorContainer"]
}
